vec2 CalcParallaxTexCoords(sampler2D displacementMap, mat3 tbnMatrix, vec3 directionToEye, vec2 texCoords, float displacementScale, float displacementBias)
{
	return texCoords + (tbnMatrix * directionToEye).xy * (texture2D(displacementMap, texCoords).r * displacementScale + displacementBias);
}

// Returns 0 for the pixels in shadow
// Returns 1 for the pixels NOT in shadow
float SampleShadowMap(sampler2D shadowMap, vec2 coords, float compare)
{
	// if (texture2D(shadowMap, shadowMapCoords.xy).r < compare) { return 0; } else { return 1; }
	return step(compare, texture2D(shadowMap, coords.xy).r); // The step function gives the same functionality as the code snippet above
}

// Returns 0 for the pixels COMPLETELY in shadow
// Returns 1 for the pixels NOT in shadow
// Returns some number in range [0;1] for other pixels
float SampleShadowMapLinear(sampler2D shadowMap, vec2 coords, float compare, vec2 texelSize)
{
	/**
	 * Texel size is supposed to be equal to 1 / shadowMap.widht (or height), so in other words
	 * pixelPos = coords * shadowMap.width which gives pixel position in an unormalized way (not in range [0;1] but [0;shadowMap.width]).
	 * We're offsetting everything by vec2(0.5) so that pixel position is based on center of the pixel and not its corner.
	 * It's also useful for the floor function used later to round the results.
	 */ 
	vec2 pixelPos = coords / texelSize + vec2(0.5);
	vec2 fracPart = fract(pixelPos); // fractional part of the pixel position (for further use in linear interpolation method)
	vec2 startTexel = (pixelPos - fracPart) * texelSize; // getting back to the normalized position in range [0;1]
	
	// Remember [0;0] is the bottom left corner!
	float bottomLeftTexel = SampleShadowMap(shadowMap, startTexel, compare);
	float bottomRightTexel = SampleShadowMap(shadowMap, startTexel + vec2(texelSize.x, 0.0), compare);
	float topLeftTexel = SampleShadowMap(shadowMap, startTexel + vec2(0.0, texelSize.y), compare);
	float topRightTexel = SampleShadowMap(shadowMap, startTexel + texelSize, compare);
	
	// interpolating begins. The order of interpolation (two mix function below) doesn't matter.
	// The mix() function is a LERN (linear interpolation).
	float mixA = mix(bottomLeftTexel, topLeftTexel, fracPart.y); // going from bottom to up (i.e. vertically), so we use fracPart.y
	float mixB = mix(bottomRightTexel, topRightTexel, fracPart.y); // going from bottom to up (i.e. vertically), so we use fracPart.y
	
	return mix(mixA, mixB, fracPart.x); // now, we are interpolating on X axis
}

// PCF (Percentage Closer Filtering)
float SampleShadowMapPCF(sampler2D shadowMap, vec2 coords, float compare, vec2 texelSize)
{
	const float NUM_SAMPLES = 3.0f;
	const float SAMPLES_START = (NUM_SAMPLES - 1.0f) / 2.0f;
	const float NUM_SAMPLES_SQUARED = NUM_SAMPLES * NUM_SAMPLES;
	
	float result = 0.0;
	for (float y = -SAMPLES_START; y <= SAMPLES_START; y += 1.0)
	{
		for (float x = -SAMPLES_START; x <= SAMPLES_START; x += 1.0)
		{
			vec2 coordsOffset = vec2(x, y) * texelSize;
			result += SampleShadowMapLinear(shadowMap, coords + coordsOffset, compare, texelSize);
		}
	}
	
	return result / NUM_SAMPLES_SQUARED; // average over all samples
}

// TODO: Write comment
float linstep(float low, float high, float compareValue)
{
	return clamp((compareValue - low) / (high - low), 0.0, 1.0);
}

// Variance shadow mapping (check Chebyshev inequality)
float SampleVarianceShadowMap(sampler2D shadowMap, vec2 coords, float compare, float varianceMin, float lightBleedingReductionAmount)
{
	vec2 moments = texture2D(shadowMap, coords.xy).xy;
	float p = step(compare, moments.x); // if pixel if completely in light then p = 1
	float variance = max(moments.y - moments.x * moments.x /* in the beginning it is zero */, varianceMin);
	
	float d = compare - moments.x; // the distance from the mean
	/* pMax = the maximum percentage of values that are greater than or equal to our compare value. Cannot be greater than 0.5 */
	float pMax = linstep(lightBleedingReductionAmount, 1.0, variance / (variance + d * d));
	
	return min(max(p, pMax), 1.0); // in case pMax is greater than 1.0
	
	//return step(compare, texture2D(shadowMap, coords.xy).r); // The step function gives the same functionality as the code snippet above
}
